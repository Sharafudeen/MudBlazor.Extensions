@typeparam T
@inherits MudExBaseComponent<MudExTreeView<T>>
@namespace MudBlazor.Extensions.Components
@using MudBlazor.Extensions.Components.ObjectEdit
@using MudBlazor.Extensions.Core
@using Nextended.Core.Extensions
@using Nextended.Core.Types

<MudExTagField Immediate="true"
               ChipColor="MudExColor.Primary"
               @bind-Values="FilterManager.Filters" @bind-Value="Filter" T="string"></MudExTagField>

<RenderChild Condition="@(ShouldRenderViewMode(TreeViewMode.Default))">
    <MudTreeView Color="Color.Primary" Hover="true" Items="@FilterManager.FilteredItems()" Dense="@Dense">
        <ItemTemplate>
            @{
                var search = FilterManager.GetMatchedSearch(context);
                @if (search.Found)
                {
                    @ItemRender(context, TreeViewMode.Default, search.Term)
                }
            }
        </ItemTemplate>
    </MudTreeView>
</RenderChild>

<RenderChild Condition="@(ShouldRenderViewMode(TreeViewMode.Breadcrumb))">
    <MudToolBar Dense="@Dense" WrapContent="true">
        @MenuFor(FilterManager.FilteredItems())
        @foreach (var item in Path())
        {
            <p>@ItemRender(item, TreeViewMode.Breadcrumb)</p>
            @MenuFor(item.Children)
        }
        <MudSpacer />
        <MudExToggleableSearch FilterMode="PropertyFilterMode.AlwaysVisible" ChipVariant="Variant.Text" MultiSearch="true" @bind-Filters="FilterManager.Filters" @bind-Filter="Filter"></MudExToggleableSearch>
    </MudToolBar>
</RenderChild>

<RenderChild Condition="@(ShouldRenderViewMode(TreeViewMode.List))">
    <MudList Style="@ListBoxStyleStr()" Dense="@Dense" Clickable="true">
        @{
            var root = false;
            HashSet<T> nodes = (selectedNode != null ? (selectedNode.Children?.Any() == true ? selectedNode.Children : selectedNode?.Parent?.Children) : null);
            if (nodes == null)
            {
                nodes = FilterManager.FilteredItems();
                root = true;
            }
        }
        @if (selectedNode != null && !root)
        {
            T targetNode = selectedNode.Children?.Any() == true ? selectedNode.Parent : selectedNode.Parent.Parent;
            <MudListItem OnClick="@(() => NodeClick(targetNode))" Text="@TryLocalize(BackLinkLabel, TextFunc(targetNode))" Icon="@Icons.Material.Filled.ArrowBack" />
            <MudDivider />
        }
        @foreach (var item in nodes.EmptyIfNull())
        {
            var search = FilterManager.GetMatchedSearch(item);
            if (search.Found)
            {
                @ItemRender(item, TreeViewMode.List, search.Term)
            }
        }
    </MudList>
</RenderChild>

<RenderChild Condition="@(ShouldRenderViewMode(TreeViewMode.Horizontal))">
    <MudAlert Severity="Severity.Warning">Experimental try out. DO NOT USE !</MudAlert>
    <div style="padding: 9px; height: 350px; width: 850px;">
        <div @onkeydown="KeyDown" @onwheel="OnWheel" tabindex="0" class="mud-ex-horizontal-tree-wrapper">
            <div class="mud-ex-horizontal-tree">
                <div style="@ScrollHorizontalTree(selectedNode)" class="mud-ex-horizontal-tree-scroll-wrapper">
                    @{
                        var items = FilterManager.FilteredItems()?.Where(n => FilterManager.GetMatchedSearch(n).Found).ToList() ?? new List<T>();
                    }
                    @NodeColumn(items, "mud-ex-horizontal-tree-node", NodeOffset(items))
                    @foreach (var node in Path().Where(n => FilterManager.GetMatchedSearch(n).Found))
                    {
                        @NodeColumn(node, NodeOffset(node))
                    }
                </div>
            </div>
        </div>
    </div>
</RenderChild>



@code {

    private RenderFragment NodeColumn(T node, double top)
    {
        return NodeColumn(node?.Children?.Where(n => FilterManager.GetMatchedSearch(n).Found), GetNodeClass(node), top);
    }

    private RenderFragment NodeColumn(IEnumerable<T> nodes, string cls, double top)
    {
        return @<div class="mud-ex-horizontal-tree-column">
        @foreach (var child in nodes ?? Enumerable.Empty<T>())
    {
    var search = FilterManager.GetMatchedSearch(child);
        @if (search.Found)
        {
            <div class="@GetNodeClass(child)" style="@GetTransformStyle(child, top)" @onclick="() => NodeClick(child)">
                <div>
                    @ItemRender(child, TreeViewMode.Horizontal, search.Term)
                </div>
            </div>
        }
    }
    </div>
        ;
    }

    private RenderFragment MenuFor(IEnumerable<T> items, bool isSubMenu = false)
    {
        var hierarchicals = items as T[] ?? items?.ToArray();
        return
        @<RenderChild Condition="@(hierarchicals?.Any(i => FilterManager.GetMatchedSearch(i).Found) == true)">
            <MudMenu ActivationEvent="@(isSubMenu ? MouseEvent.MouseOver : MouseEvent.LeftClick)"

                     AnchorOrigin="Origin.TopRight"
                     TransformOrigin="Origin.TopLeft"
                     MaxHeight="500"
                     Dense="@Dense"
                     EndIcon="@ExpandedIcon"
                     Icon="@(isSubMenu ? null : ExpandedIcon)">
                @foreach (var child in hierarchicals)
                {
                    var search = FilterManager.GetMatchedSearch(child);
                    @if (search.Found)
                    {
                        @ItemRender(child, TreeViewMode.Breadcrumb, search.Term, true)
                    }
                }
            </MudMenu>
        </RenderChild>;
    }

    public virtual RenderFragment RenderSeparator() => @<MudExDivider />;

    private RenderFragment ItemRender(T item, TreeViewMode viewMode, string search = "", bool asMenuItem = false)
    {
        var context = new TreeViewItemContext<T>(item, IsSelected(item), IsExpanded(item), search, asMenuItem, viewMode, this);
        if (ItemTemplate != null)
            return ItemTemplate(context);

        return IsSeparator(item) ? RenderSeparator() : RenderItem(context);
    }

    public virtual RenderFragment RenderItem(TreeViewItemContext<T> context)
    {
        return
            @<RenderChild>
                @if(context.ViewMode == TreeViewMode.Default) {
                    <MudTreeViewItem Expanded="@IsExpanded(context.Item)"
                                     Style="@("cursor: pointer;")"
                                     Class="@TreeItemClassStr()"
                                     OnClick="@(() => NodeClick(context.Item))"
                                     Items="@(context.Item?.Children?.ToHashSet())">
                        <Content>
                            <MudTreeViewItemToggleButton ExpandedIcon="@ExpandedIcon" ExpandedChanged="@(expanded => SetExpanded(context.Item, expanded))" Expanded="@context.IsExpanded" Visible="@(context.Item?.Children?.Any() == true)" />    
                            @RenderItemContent(context)
                        </Content>
                    </MudTreeViewItem>   
                } else if(context.ViewMode == TreeViewMode.List) {
                    <MudListItem OnClick="@(() => NodeClick(context.Item))">
                        <div class="@ListItemClassStr()">
                            @RenderItemContent(context)
                        @if(context.Item.HasChildren())
                        {
                            <MudExIcon Icon="@ExpandedIcon" />
                        }
                        </div>
                    </MudListItem>

                } else if(context.ViewMode == TreeViewMode.Breadcrumb && context.RenderedAsMenuItem) {
                    <MudMenuItem Style="flex-flow: row-reverse;" Icon="@(context.Item.HasChildren() ? null : null)" OnClick="@(() => NodeClick(context.Item))">
                        @RenderItemContent(context)
                        @*
                        @if(context.Item.HasChildren())
                        {
                            @MenuFor(context.Item.Children, true)
                        }*@
                    </MudMenuItem>
                } else if (context.ViewMode == TreeViewMode.Horizontal)
                {
                    <div class="@ListItemClassStr()">
                        @RenderItemContent(context)
                        @if(context.Item.HasChildren())
                        {
                            <MudExIcon Icon="@ExpandedIcon" />
                        }
                    </div>
                }
                else{
                    @RenderItemContent(context)
                }
            </RenderChild>;
    }

    public virtual RenderFragment RenderItemContent(TreeViewItemContext<T> context)
    {
        if (ItemContentTemplate != null)
            return ItemContentTemplate(context);
        return
        @<MudText Class="trimmer" Style="@($"color: {(context.IsSelected ? MudExColor.Secondary.ToCssStringValue() : "inherit")};")">@TextFunc(context.Item)</MudText>;
    }

}
