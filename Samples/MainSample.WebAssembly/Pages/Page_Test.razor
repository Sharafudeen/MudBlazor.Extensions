@page "/test"
@using FluentValidation
@using BlazorJS


<MudExTextField Variant="Variant.Outlined" Class="m-2" T="string" Adornment="@Adornment.Start" AdornmentIcon="@Icons.Custom.Brands.Apple" Clearable="true">
    <MudExAdditionalAdornment Position="MoveContentPosition.AfterEnd">
        <MudTooltip Text="I'm a another separate control inside of the normal input">
            <MudIconButton Icon="@Icons.Material.Filled.Coffee"></MudIconButton>
        </MudTooltip>
        <MudTooltip Text="I'm a separate control inside of the normal input">
            <MudIconButton OnClick="@(() => JsRuntime.AlertAsync("Hello"))" Icon="@Icons.Material.Filled.AccessAlarms"></MudIconButton>
        </MudTooltip>
    </MudExAdditionalAdornment>
</MudExTextField>

<MudExTextField Variant="Variant.Outlined" Class="m-2" T="string" Adornment="@Adornment.Start">
    <MudExAdditionalAdornment Position="MoveContentPosition.AfterEnd">
        <MudTooltip Text="I'm a another separate control inside of the normal input">
            <MudIconButton Icon="@Icons.Material.Filled.Coffee"></MudIconButton>
        </MudTooltip>
        <MudTooltip Text="I'm a separate control inside of the normal input">
            <MudIconButton OnClick="@(() => JsRuntime.AlertAsync("Hello"))" Icon="@Icons.Material.Filled.AccessAlarms"></MudIconButton>
        </MudTooltip>
    </MudExAdditionalAdornment>
</MudExTextField>

<MudExAdditionalAdornment Position="MoveContentPosition.BeforeEnd">
    <For>
        <MudExTextField Variant="Variant.Outlined" Class="m-2" T="string" Adornment="@Adornment.Start" />
    </For>
    <ChildContent>
        <MudIconButton Title="I'm a separate control inside of the normal input" OnClick="@(() => JsRuntime.AlertAsync("Hello"))" Icon="@Icons.Material.Filled.AccessAlarms"></MudIconButton>
        <MudIconButton Title="I'm a another separate control inside of the normal input" OnClick="@(() => JsRuntime.AlertAsync("Hello from me as well"))" Icon="@Icons.Material.Filled.Coffee"></MudIconButton>
    </ChildContent>
</MudExAdditionalAdornment>

<MudExAdditionalAdornment>
    <For>
        <MudExTextField Variant="Variant.Outlined" Class="m-2" T="string" Adornment="@Adornment.Start" AdornmentIcon="@Icons.Custom.Brands.Apple" Clearable="true" />
    </For>
    <ChildContent>
        <MudTooltip Text="I'm a separate control inside of the normal input">
            <MudIconButton Icon="@Icons.Material.Filled.AccessAlarms"></MudIconButton>
        </MudTooltip>
        <MudTooltip Text="I'm a another separate control inside of the normal input">
            <MudIconButton Icon="@Icons.Material.Filled.Coffee"></MudIconButton>
        </MudTooltip>
    </ChildContent>
</MudExAdditionalAdornment>

<MudExAdditionalAdornment>
    <For>
        <MudExTextField Variant="Variant.Outlined" Class="m-2" T="string" Adornment="@Adornment.End" AdornmentIcon="@Icons.Custom.Brands.Apple" Clearable="true" />
    </For>
    <ChildContent>
        <MudTooltip Text="I'm a separate control inside of the normal input">
            <MudIconButton Icon="@Icons.Material.Filled.AccessAlarms"></MudIconButton>
        </MudTooltip>
        <MudTooltip Text="I'm a another separate control inside of the normal input">
            <MudIconButton Icon="@Icons.Material.Filled.Coffee"></MudIconButton>
        </MudTooltip>
    </ChildContent>
</MudExAdditionalAdornment>


<MudCard>
    <MudForm Model="@model" @ref="@form" Validation="@(ValidationRules.ValidateValue)" ValidationDelay="0">
        <MudCardContent>
            <MudTextField @bind-Value="model.Name"
                          For="@(() => model.Name)"
                          Immediate="true"
                          Label="Name" />



            <MudExUploadEdit T="UploadableFile"
                             Variant="Variant.Outlined"
                             For="@(() => model.Files)"
                             TextUploadFile="Click here to upload files"
                             TextDropZone="Drag and Drop files here"
                             Label="Add files"
                             ColorizeIcons="true"
                             MinHeight="80"
                             Class="MudExUploadExCustom"
                             AllowRename="true"
                             @bind-UploadRequests="model.Files">
            </MudExUploadEdit>

        </MudCardContent>
        <MudCardActions>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="ml-auto" OnClick="@(async () => await Submit())">Submit</MudButton>
        </MudCardActions>
    </MudForm>
</MudCard>



@code {
    private MudForm form;
    private FileModel model = new();
    private FileModelFluentValidator ValidationRules = new();


    private async Task Submit()
    {
        await form.Validate();

        if (form.IsValid)
        {

        }
    }

    public class FileModel
    {
        public string Name { get; set; }
        public IBrowserFile File { get; set; }
        public IList<UploadableFile> Files;

    }

    /// <summary>
    /// A standard AbstractValidator which contains multiple rules and can be shared with the back end API
    /// </summary>
    /// <typeparam name="OrderModel"></typeparam>
    public class FileModelFluentValidator : AbstractValidator<FileModel>
    {
        public FileModelFluentValidator()
        {
            RuleFor(x => x.Name)
                .NotEmpty()
                .Length(1, 100);
            RuleFor(x => x.File)
            .NotEmpty();
            RuleFor(x => x.Files)
                .NotEmpty();
            When(x => x.File != null, () =>
            {
                RuleFor(x => x.File.Size).LessThanOrEqualTo(10485760).WithMessage("The maximum file size is 10 MB");
            });
        }

        public Func<object, string, Task<IEnumerable<string>>> ValidateValue => async (model, propertyName) =>
        {
            var result = await ValidateAsync(ValidationContext<FileModel>.CreateWithOptions((FileModel)model, x => x.IncludeProperties(propertyName)));
            if (result.IsValid)
                return Array.Empty<string>();
            return result.Errors.Select(e => e.ErrorMessage);
        };
    }
}
